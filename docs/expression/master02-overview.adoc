= Overview

The openEHR Expression Object Model (EOM) defines the semantics of all of the elements of computable expressions that are used in openEHR, and are likely to be used in healthcare and life sciences computing where rules and expressions are needed. The model is designed as an extensible core formalism suitable for use and extension in other formalisms (such as the openEHR Archetype formalism).

The openEHR Expression Language (EL) specified here is an abstract syntax counterpart to the Expression Object Model, and may be considered a 'default syntax'. Other syntaxes or syntax variants are certainly possible, and other serialisation methods are possible, such as object graph serialisation into XML, JSON, YAML etc. The EL is provided firstly as a way of specifying and explaining the semantics of the EOM, and secondly, as one way of actually authoring expressions and rules in textual form. This approach is the same as with any programming language, where the usual form for learning and programming is the abstract language form, while the computational form is an abstract syntax tree (AST) or similar.

Accordingly, the EOM should be considered the normative definition of the openEHR Expression formalism, and indeed not all implementations need support the language: they might for example only serialse in JSON or use purely graphical visualisation.

The formalism as defined here requires extensions for use, at a minimum to provide concrete value referencing. Extensions would also typically provide more operators, functions, leaf types and other features that are needed in specific circumstances.

Key features of the formalism include:

* variable declarations, assignments and expressions;
* strong typing;
* standard logical operators including universal and existential quantification, as well as user-defined operators;
* standard arithmetic and relational comparison operators, enabling the use of numerics;
* parentheses for overridding operator precedence;
* functions, including built-ins like `current_date`, standard functions such as `max()` defined on primitive types, as well as the ability to use external functions.

For reasons of comprehensibility and explanation, the Expression Language is defined first in this specification.

== Design Background

The openEHR Expression Language is based on a limited first-order predicate logic language. It has similarities with {omg_ocl}[OMG's OCL (Object Constraint Language)^], and to the assertion syntax used in the Object-Z language cite:[Object_Z]. See citenp:[Sowa2000], citenp:[Hein2002], citenp:[Kilov1994] for an explanation of predicate logic in information modelling. It also draws on the semantics and some of the syntax (particularly agent-related) of the Eiffel Language ({eiffel_ecma_367}[ECMA-367^]). It is not exactly the same as any of these languages because:

* it has a different target meta-model, namely the BMM `expression` model;
* the syntax is designed to be comprehensible to developers familiar with modern mainstream object-oriented and functional languages such as Java, C#, Python, TypeScript etc.

Modern syntaxes that provide a more generic and minimal inspiration for the expression syntax described here include the {w3c_xpath}[Xpath syntax].

The semantic requirements are for expressions including arithmetic, boolean, and relational operators, functions, quantifier operators, operator precedence, parentheses, constant values, and certain kinds of variables. However, there is no support in the core specification for procedural semantics or most of the other complexities of full-blown programming languages.

== Execution Model

The assumed execution model of the Expression language is that an EL text is evaluated by an _evaluator_ against a _data context_, which determines the truth values of the expression(s). The data context typically includes data services such as the EHR, patient demographics, laboratory systems and so on - anything that is available computationally via some service. The text may contain symbols representing internal variables and bound variables, the latter of which map to entities in the data context.

No assumption is made about whether the data context used is complete or faithful to reality. Consequently, the _expression universe_ is technically speaking an 'open world' in the sense of the {wikipedia_open_world_assumption}[open-world assumption]. However, higher-level applications or components (or users) may have sufficient knowledge about the data as to be able to treat it in a closed world fashion, for example to treat absence of X as negation of X.

== General Structure

The Expression Language may be used to write single Boolean-valued expressions within another computational context, and in future, a multi-section self-standing `EL text` with a similar structure to an archetype. Expressions may be _declarations_, _assignments_ or _assertions_. These are made up of expressions containing _symbols_ which represent typed _variables_ and _constants_. Variables are either _bound_ or _local_, and are defined using `$` names, e.g. `$heart_rate` as used in shell script and some other programming languages. A bound variable is mapped to a field in the data context. In the current version of the language, this is achieved by assignment statements that either assign a path in the data context to a symbolic variable (reading) or the reverse (writing back). In this sense, 'assignment' can be understood as _associating_ a data context path with a named variable.