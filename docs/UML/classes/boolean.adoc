=== Boolean Class

[cols="^1,3,5"]
|===
h|*Class*
2+^h|*Boolean*

h|*Description*
2+a|Class representing minimal interface of standard Boolean type.

h|*Inherit*
2+|`<<_any_class,Any>>`

h|*Functions*
^h|*Signature*
^h|*Meaning*

h|*1..1*
|*infix and* ( +
other: `<<_boolean_class,Boolean>>[1]` +
): `<<_boolean_class,Boolean>>` +
 +
__Post_de_Morgan__: `Result = not (not self or not other)` +
__Post_commutative__: `Result = (other and self)`
a|Logical conjunction

h|*1..1*
|*infix and_then* ( +
other: `<<_boolean_class,Boolean>>[1]` +
): `<<_boolean_class,Boolean>>` +
 +
__Post_de_Morgan__: `Result = not (not self or else not other)`
a|Boolean semi-strict conjunction with other

h|*1..1*
|*infix or* ( +
other: `<<_boolean_class,Boolean>>[1]` +
): `<<_boolean_class,Boolean>>` +
 +
__Post_de_Morgan__: `Result = not (not self and not other)` +
__Post_commutative__: `Result = (other or Current)` +
__Post_consistent_with_semi_strict__: `Result implies (self or else other)`
a|Boolean disjunction with other.

h|*1..1*
|*infix or_else* ( +
other: `<<_boolean_class,Boolean>>[1]` +
): `<<_boolean_class,Boolean>>` +
 +
__Post_de_Morgan__: `Result = not (not self and then not other)`
a|Boolean semi-strict disjunction with `other'.

h|*1..1*
|*infix xor* ( +
other: `<<_boolean_class,Boolean>>[1]` +
): `<<_boolean_class,Boolean>>` +
 +
__Post_definition__: `Result = ((self or other) and not (self and other))`
a|Boolean exclusive or with `other'.

h|*1..1*
|*infix implies* ( +
other: `<<_boolean_class,Boolean>>[1]` +
): `<<_boolean_class,Boolean>>` +
 +
__Post_definition__: `Result = (not self or else other)`
a|Boolean implication of `other' (semi-strict)

h|*Invariants*
2+a|__Involutive_negation__: `is_equal (not (not self))`

h|
2+a|__Non_contradiction__: `not (self and (not self))`

h|
2+a|__Completeness__: `self or else (not self)`
|===
